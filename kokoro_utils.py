import logging
import numpy as np
import soundfile as sf
from typing import List, Dict

try:
    from kokoro.g2p.pipelines import KPipeline
    KOKORO_AVAILABLE = True
except ImportError:
    KOKORO_AVAILABLE = False
    logging.warning("Kokoro TTS not available.")

def _clean_text_for_tts(text):
    # A simple cleaner, can be expanded.
    text = text.replace("*", "").strip()
    return text

def generate_audio_overview_kokoro(script: List[Dict], output_path: str):
    """
    Generates an audio overview of the script using Kokoro TTS.
    """
    if not KOKORO_AVAILABLE:
        logging.error("Kokoro TTS is not installed. Cannot generate audio.")
        return False

    try:
        SAMPLING_RATE = 24_000
        logging.info("Initializing Kokoro TTS pipeline...")
        pipline = KPipeline(lang_code='a')

        final_audio_chunks = []

        def text_to_audio(input_text):
            """Helper function to convert a single text string to an audio chunk."""
            if not input_text or not input_text.strip():
                return None
            try:
                clean_text = _clean_text_for_tts(input_text)
                # The voice 'af_heart' is from the user's snippet. This might need to be configurable.
                generator = pipline(clean_text, voice='af_heart', split_pattern=r'\n+')
                chunks = [audio for _, _, audio in generator]
                if chunks:
                    return np.concatenate(chunks)
            except Exception as e:
                logging.error(f"Error during Kokoro TTS generation for text: '{input_text[:50]}...'. Error: {e}")
            return None

        for line in script:
            text = line.get("text", "")
            if text:
                audio_chunk = text_to_audio(text)
                if audio_chunk is not None:
                    final_audio_chunks.append(audio_chunk)
                    # Adding a small pause between lines
                    final_audio_chunks.append(np.zeros(int(0.5 * SAMPLING_RATE), dtype=np.float32))

        if not final_audio_chunks:
            logging.warning("No audio was generated by Kokoro TTS.")
            return False

        full_audio = np.concatenate(final_audio_chunks)
        sf.write(output_path, full_audio, SAMPLING_RATE)
        logging.info(f"Kokoro TTS audio successfully saved to {output_path}")
        return True

    except Exception as e:
        logging.error(f"An error occurred during Kokoro audio generation: {e}")
        return False
